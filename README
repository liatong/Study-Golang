
=========test1 ======

=========demo5  主要用于学习go语言当中的面向对象基础理论知识。==========
//包含有
//go 语言中没有传统的继承，构造函数等语法。而是在语言系统里面把面向对象的东西涵盖进去
//类型系统，通过接口串联焕然一体。---》这个需要一定的特别解释。 

类型系统是一门编程语言的核心基础，是至关重要的。，
通俗的讲，类型系统就是指， 这门编程语言中都具备了哪些类型，这些类型都是如何从无或从原始状态给设计出来的。
类型被设计，就会是依赖于本语言中的面向对象特性。而这些类型是一门语言当中最基础的东西，并且同时这个语言的对象模式（这是构建出基础类型的基础）
所以这里才会说，一个语言中的类型系统是最基础。 

/////那么go语言当中的类型系统会是什么样的？按照理解的话，会是怎样构造出来的。 
拿Java对比，Java有两套类型系统，一套是值语意类型，另外一套是object的对象类型。
而go，简单来说就只有一套值类型。并且能够给这个值类型加上方法。按照我自己土办法来理解，就是这些类型都是一个接口定义而已。
至于说一些看起来如map，等也不过是把一些内存值类型等存储地址，放入值当中而已。说到底，还不是一样是值而已。

而这些如何构建出来，就只是定义一个interface()，struct，然后给不同的类型附上方法。 



======== demo6 
主要是以一个小的实例验证一下，以上学习的内容。
	//&取了对象的地址，交给别人，别人是指针变量。 mm是一个指针变量，存的是指针。   *mm 地址变量被解开，变回来了具体的对象。p就又编程是一个变量而已。存储着对象的地址。

	//mm本身是个变量，有自己的地址空间。mm里面存的是别人的地址。这个地址指向的是一个对象。能引用。
	// 0x00000（mm)-> 0x30000 -> object
	//*mm 取地址指向的具体值。  p := *mm  . p = 0x30000(p)-->object


========  demo7
并发有多种方式：
1、多进程；系统开销大
2、多线程，使用较多，但开销仍然较大。
3、协程，开销小。

go的协程特性：
	go当中的标准库，提供的所有系统调用操作，包括所有的同步io操作，也都会出让CPU给其他啊goroutine。这也就是说本身协程的切换是不依赖于系统本身的进程和线程切换。
	而是在系统的基本库就已经支持好了。
	
	
如何让一个功能在一个新的协程中取执行呢？
	在函数前面加上go 关键字就能够让程序在协程中被执行。当被调用的功能函数返回的时候。这个goroutine也就自动结束了。需要注意的是，如果这个函数有返回值也会被丢弃的。
	
主进程没等待所有协程执行完毕就退出了，协程结果没打印出来？如何等待？
	并发是一个问题。并发编程都难度在于协调，避免多个线程之间产生了数据冲突等，所以需要彼此进行协调。而协调的办法就能够彼此进行交流。
	交流就是不同并发单元之间需要通讯。 
	通讯的手段有：  共享数据、 消息
	共享数据有多种形态： 内存，数据库，共享文件，网络数据等。
	所以一些数据就需要转存到具体的数据库，共享文件或者网络上去。
	
go语言的并发理解
	每个并发单元都是自包含的独立的个体，并且有自己的变量，并且这些变量不共享。而对于独立的并发单元来说，唯一接触的就是消息。 针对并发单元的输入与输出，就是消息。 
	在go当中，这些消息就是通过消息通道来进行传递。在go当中也就是channel。
	
channel
	channel是进程级别的。在进程内的协程之间通讯使用channel来实现。，
	channel和函数一样，对参数是有类型区分的。
	channel因为是在不同协程间传递消息，也就有方向性。 
	channel就是不同协程间的通道。

select
	select机制很早就被引入了，select函数被用来监控一些列的文件句柄。在这些文件句柄中，一旦有一个句柄发生了IO操作。那么该selec()就会被调用。于是这样的作用就被用来
	处理并发的socket服务程序了。在我们已经创建出来的要处理的IO操作中，一旦有一个句柄（进程IO）被返回的时候，就会被调用，此时就能够通知函数接着处理了。
	在go当中也是在语言级别就支持select关键字。 用来处理异步IO问题。 
	
	异步IO
		也就是说，我们在做这个IO操作的时候，其实是不用等在哪里等执行完成在做之后的事情。可以呼叫完成，然后让它自己去处理。
		
	select写法
		select的写法和switch差不多，只是每个case都必须是一个chan处理。并且select是顺序匹配case条件的，都会匹配。默认都没有的话，会进入到default去进行匹配。
		
	select{
		case <- channel1:
			fmt.print("asa")
		case ch <- 1:
			fmt.print("out 1 to channel")
		default:
			fmt.print("the last case.")
	}

channel超时问题。
	select会等到case中的消费。如果没有defaul，还希望针对某一个chanel不要一直等着。而要具备超时机制。这种就是避免有时候，我们程序会无休止的等待一个不重要或
	是一个不重要的业务环节，或不可预判不可预期的IO访问。
	go func(){
		tiem.Sleep(1e9)
		timeout <- true
	}
	select{
		case <-ch:
			//do something
		case <-timeout:
			//timeout
			
	}

channel的缓冲机制
	channel之前创建的channel都是单个消息通道，如果消息一直没有被消费走的话，后续的消息是不能再被写入的。这样也就会造成阻塞了。
	为此我们能够创建一个带有大小的channel，保证在消息还没有被消费的时候，可以留存在channel当中。
	c := make(chan int ,1024)   创建了一个有1024大小的int channel
	
channel的方向性及关闭
	单向   var c1 chan<-  只可进
			var c2  <-chan 只可出
	
	关闭
		close（ch）
		
		
go当中的同步锁
	sync.Mutex暴力锁，只要锁其他都不可操作。
	sync.RWMutex,写锁，不可读写。 读锁，不可写可读。
	var lock sync.Mutex
	func foo(){
		l.Lock()
		share1 ++
		defer l.Unlock
	}
	
全局唯一性操作
	这里所谓都全局是指，当前进程内，仅操作一次。
	var once sync.Once
	func doinitwork(){
		once.Do(readconfig)
		fmt.print(a)
	}
	func readconfig(){
		//read config
	}
	go doinitwork()
	go doinitwork()
	就算这里有多个协程调用了，但readconfig函数最终也只会被执行一次而已。
	
	// 这里有一个比较重要的坑，就是map需要通过make先进行初始化。不然会提示 panic: assignment to entry in nil map。
	//这里提示不能把东西赋值给一个空的map上面。
	var m map[string]chan string
	m = make(map[string]chan string)
	
=====ipcserver 
	经历过这个实际的实验。至少自己成功的试过一次，从只有需求到，自己分析。然后自己完整的构造出来具体的代码。
	然后能够真正的自主的把一些东西给实现出来。然后还有一些细节上的东西需要注意。 
	比如map需要先make才能够去使用。
	
	然后抽象出来的实体之间的关系是什么样的。业务和功能梳理出来之后，就是定大概的逻辑结构。逻辑结构没什么问题之后，就是定义彼此之间的数据接口如何交换数据。
	再然后，就是按照某一个具体的业务线，把伪代码结构给罗列出来。于此同时，最好在确定了整体的代码逻辑结构之后，就把对应的函数对象测试。对象之间的调用关系测试，给补齐。
	之后，就可以具体去写详细的代码细节。
	
	==ipcserver中暴露的一点？
	==什么时候该使用对象指针的方式传递参数和返回值。如果没有使用指针形式作为参数，和有使用有什么差异。
	-按照目前来看，别人在用一般也都是传指针都形式。 
	-但是我自己在实验的话，传值和传指针，都是可以使用的啊。 --->错了，如果会改变对象本身的方法，确实是需要传递对象本身的指针过去的。
	--》以上是针对对象本身的方法。 
	--》那除此之外的，为什么有些方法却是要给别的人传递指针呢？难道也是为了，让在本函数内部创建出来的东西，和从函数传递回去的东西是同一个所以是传递指针，而不是传递值的形式。
	--》可以做个验证。一个对象，有一个函数，创建另外一个对象，一个保存在本对象的属性中。另一个返回回去。然后新对象有方法。通过这个方法能够改变自身的值。最终在看看这个是不是同一个指。 
	!!!-->经过最终的验证，确实也是，如果你希望在函数当中创造的东西，在函数内部，和函数返回值之后，能够同一个对象。那就要传递指针的形式。如果只是简单的传值的话。那只能是当下的状态是一样的。
	!!!-->后续改变的值，就不能够同步了。 
	type Student struct {
		Name string
	}
	
	func (s Student) Say() {
		fmt.Print("\nmy name is:", s.Name)
	}
	func (s *Student) ChangeName(name string) {
		s.Name = name
		fmt.Print("\nmy name change to :", s.Name)
	}
	type ClassRoom struct {
		Students map[string]*Student
	}

	func (cr *ClassRoom) NewStudent(id, name string) Student {
		s := Student{name}
		cr.Students[id] = &s
		return s
	}
	st := cr.NewStudent("001", "li")
	cr.Students["001"].Say() -->li 
	st.Say() --> li
	cr.Students["001"].ChangeName("changeName")
	cr.Students["001"].Say() -->changeName
	st.Say() --> li
	这里就可以看得出来，如果想保留这个对象本身。不是影分身，那就要传递指针，而不是单纯的传递值就可以。 在go当中描述为传值，还是传引用（指针）
	
	
	
	